Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система обслуговування користувачів електромобілів

Студентка гр. ПЗПІ-21-10	__________________ Матюшенко І.В.
(підпис)
Керівник роботи	__________________ доц. Лещинська І.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6			
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Матюшенко Ірині Вячеславівні
1.	Тема роботи: «Програмна система обслуговування користувачів електромобілів»
2.	Термін узгодження завдання курсової роботи «24»_березня__ 2024 р.
3.	Термін здачі студентом закінченої роботи «31»___травня____ 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
Програмна система, що стане результатом розробки, має надавати наступний функціонал: розбиття користувачів по ролям (адміністратор, працівник, клієнт)б можливість для клієнтів створювати запити за обслуговування автомобіля, та редагувати існуючі, можливість використовувати смарт-девайс для зарядки електромобіля. Також для кожного авто має зберігатися історія заряджань, у якому зокрема буде доступна історія перегрівань батареї та інших інцидентів, що трапляються протягом зарядки. Також система має підтримувати адміністрування, керування ролями користувачів та існуючими сервісними станціями. При розробці використовувати СКБД PostgreSQL, середовище розробки Visual Studio Code. Система має складатися з 4 компонентів (Back-end, Front-end, Mobile app, IoT)			
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз та концептуальне моделювання предметної області, проєктування програмної системи, розробка серверної частини системи, розробка програмного забезпечення для вбудованих систем, розробка клієнтського веб-застосунку, висновки, перелік використаних джерел, додатки		
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання системи, UML діаграма прецедентів серверної частини, ER-діаграма, UML діаграма пакетів серверної частини, UML діаграма прецедентів частини для вбудованих систем, UML діаграма взаємодії частини для вбудованих систем, UML діаграма станів частини для вбудованих систем, Схема фіізичної моделі частини для вбудованих систем, UML діаграма прецедентів браузерного клієнту, UML діаграма компонентів браузерного клієнту, UML діаграма пакетів браузерного клієнту, UML діаграма діяльності браузерного клієнту			
 
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	28.03.2024	виконано
2	Проектування програмного
проекту	11.04.2024	виконано
3	Кодування програмного проекту	25.04.2024	виконано
4	Оформлення пояснювальної
записки	23.05.2024	виконано
5	Захист курсової роботи	30.05.2024	виконано

Дата видачі завдання «24» березня 2024 р.
Керівник	_______________ доц. Лещинська В.О.
(підпис)

Завдання прийняла до виконання
ст. гр. ПЗПІ-21-10	__________________   Матюшенко І.В.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 72 с., 12 рис., 2 дод., 6 джерел.
ЕЛЕКТРОМОБІЛЬ, СЕРВІС, АВТО, ПОСЛУГИ, NESTJS, REACT, ESP32,
Метою курсового проєкту є створення програмної системи для обслуговування користувачів електромобілів.
Протягом розробки було застосовано велику кількість різноманітних технологій для реалізації усіх частин системи. Серцем системи є серверна частина, для побудови якої було використано фреймворк NestJS, для доступу до сутностей у базі даних PostgreSQL використано бібліотеку TypeORM, для браузерного застосунку використано бібліотеку React, а в якості платформи для IoT-девайсу ESP32, як найкраща опція відносно вимог до платформи, на якій буде розгорнуте створене програмне забезпечення для вбудованих систем.
Результатом розробки є програмна система, що дозволяє працівникам сервісних станцій приймати та керувати запитами на послуги їхнього сервісу за допомогою відповідного браузерного застосунку. Адміністраторам надано можливість керувати наявними у системі станціями, а також ролями користувачів та їх можливостями, правами у системі. Для клієнтів станцій можливо додавати свої машини у систему, створювати запити на сервісні послуги для них, а також заряджати свою машину прямо на станції за допомогою смарт-девайсу. Більш того, девайс слідкує за станом авто протягом заряджання та попереджає клієнта про неприємні випадки, як наприклад перегрівання. Браузерна частина локалізована для української та англійської мов.
 
ЗМІСТ


ЗМІСТ	6
1	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1	Бізнес-вимоги	8
1.1.1	Передумови	8
1.1.2	Бізнес можливості	8
1.1.3	Бізнес-цілі та критерії успіху	10
1.1.4	Потреби клієнтів та ринку	10
1.1.5	Бізнес-ризики	11
1.2	Концепція рішення	12
1.2.1	Окреслення концепції	12
1.2.2	Головна функціональність	13
1.2.3	Припущення та залежності	14
1.3	Рамки та обмеження	15
1.3.1	Рамки первинного випуску	15
1.3.2	Рамки наступних випусків	16
1.3.3	Обмеження та Виключення	17
1.4	Бізнес-контекст	17
1.4.1	Профілі зацікавлених сторін	17
1.4.2	Пріоритети проєкту	20
1.4.3	Робоче середовище	21
2	ПРОЄКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ	23
2.1	Опис архітектури системи	23
2.2	Побудова діаграми розгортання	23
3	РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ	25
3.1	Опис архітектури серверної частини системи	25
3.2	Побудова діаграми прецедентів для серверної частини системи	26
3.3	Побудова ER-діаграми для серверної частини системи	26
3.4	Специфікація REST	27
3.5	Побудова діаграми пакетів для серверної частини системи	30
4	РОЗРОБКА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ ВБУДОВАНИХ СИСТЕМ	31
4.1	Концептуальне моделювання системи	31
4.2	Опис розробки застосунку для вбудованих систем	32
4.2.1	Обґрунтування архітектурних рішень проєкту	32
4.2.2	Опис використаних технологій	32
4.2.3	Опис результатів розробки частини проекту для вбудованих систем	33
4.2.4	Опис результатів тестування частини проекту для вбудованих систем	34
5	РОЗРОБКА КЛІЄНТСЬКОГО ВЕБ-ЗАСТОСУНКУ	35
5.1	Концептуальне моделювання системи	35
5.2	Опис розробки клієнтського веб-застосунку	35
5.2.1	Обґрунтування архітектурних рішень проєкту	35
5.2.2	Опис використаних технологій	36
5.2.3	Опис результатів розробки клієнтського веб-застосунку	37
5.2.4	Опис результатів тестування клієнтського веб-застосунку	38
ВИСНОВКИ	39
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ	40
ДОДАТОК А	41
ДОДАТОК Б	53

 
1	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Передумови


У галузі обслуговування електромобілів спостерігається швидке зростання попиту на ефективні та зручні сервісні рішення. Нині існує безліч програмних систем, орієнтованих на покращення процесу обслуговування та оптимізацію роботи технічних центрів. Але, на жаль, більшість з цих систем зазвичай існують достатньо давно та можуть бути застарілими. Також більшість з них орієнтовані саме на використання серед технічних фахівців, для спрощення їх робочих процесів, не беручи до уваги звичайних клієнтів. Разом із застарілим інтерфейсом, стрімке впровадження численних функцій часто призводить до заплутаних інтерфейсів та налаштувань, що створює труднощі для клієнтів з різним рівнем технічної підготовки.
Тому виникає необхідність розробки програмного забезпечення для слідкуванням за станом електромобілів та автоматизації процесу обслуговування, яке б поєднувало широкий спектр функцій для покращення сервісу з простотою, зручністю використання та приємним інтерфейсом. Така система має бути зрозумілою для всіх користувачів і водночас підвищувати якість та комфорт обслуговування електромобілів, забезпечуючи легкість та ефективність технічного обслуговування. 


1.1.2	Бізнес можливості


Аналоги на ринку:
−	Nissan EV Care: програма обслуговування для власників електромобілів Nissan, яка надає різні послуги та підтримку для забезпечення максимальної ефективності та безпеки автомобіля. З переваг має планування зарядки та оновлення в реальному часі. Недоліком є затримки в отриманні оновлень програмного забезпечення через додаток, що може впливати на ефективність використання деяких функцій.
−	Tesla Service: програмне забезпечення для віддаленого діагностування авто, відстеження його стану, запису на технічне обслуговування та отримування повідомлень про необхідні процедури. Застосунок має віддалене керування автомобілем, легке планування обслуговування та пошук зарядних станцій. Проте з недоліків можна вказати на високі вимоги до з’єднання з інтернетом та проблеми з синхронізацією. Також застосунок регулярно отримує оновлення, які можуть містити недоліки або зміни в інтерфейсі, що інколи викликає труднощі у користувачів.
−	Lucid Motors Service Application: програма для моніторингу стану автомобілів і забезпечення їхньої безперебійної роботи, що також пропонує зручні інструменти для планування обслуговування авто. Система має високу якість дизайну та функціональності, пропонує достойний рівень персоналізації, що підвищує зручність користування. Також застосунок інтегрується з іншими цифровими сервісами, що надає більше корисних функцій. З недоліків можна виділити деякі проблеми з сумісністю системи з різними моделями смартфонів та операційними системами, обмежену масштабованість та відсутність деяких функцій через те, що застосунок є новим.
Переваги програмної системи в порівнянні з наведеними аналогами полягають в зрозумілості та комфорті його використання, доступності всіх необхідних функцій без виключень, гарному дизайні та доступній вартості для усіх користувачів. Також, програма буде інтегруватися з іншими цифровими сервісами, що надаватиме більш широкий спектр функцій та можливих до використання послуг.
Ключовою стратегією монетизації створеної системи будуть оплати за використання інтегрованих в якості смарт-девайсів станцій для зарядки автомобілів, а також безпосередньо кошти, які платять клієнти за виконання їхніх запитів на сервісні послуги.


1.1.3	Бізнес-цілі та критерії успіху


Створений застосунок має збільшити кількість обслуговуваних автомобілів та загальну кількість запитів на обслуговування на 35%, і зменшити витрати на організацію на 20%. До того ж завдяки застосунку має збільшитися кількість користувачів станціями зарядок. Критерієм успіху буде збільшення кількості активних клієнтів сервісу на 35%. 


1.1.4	Потреби клієнтів та ринку


a)	Потреби користувачів:
1)	Володарі електромобілів: особи, які потребують належного обслуговування своїх автомобілів, шукають зручний спосіб планувати його заздалегідь через відповідний застосунок, а також хочуть мати можливість заряджати своє авто, відслідковуючи його стан протягом зарядки.
2)	Робітники автомобільних сервісів, які працюють в обслуговувані електромобілів і хочуть мати доступ до інструментів відстеження стану авто та мати зручний спосіб керувати поточними сервісними роботами на станції.
b)	Ринковий попит: Росте попит на користування електромобілями і, як наслідок, створюється попит на програмні системи для слідкування за авто: його станом та необхідністю технічних оглядів. Більш того, збільшується попит на станції для заряджання електромобілів
c)	Невиконані потреби: Наявні проблеми зі складністю користування та обмеженим функціоналом існуючих програм для моніторингу стану авто, що ускладнює використання для власників авто та робітників сервісів.
d)	Сценарії використання:
1)	Користувачі реєструють себе та свої електромобілі в системі та вказують свої характеристики, які наявні в авто.
2)	Система відстежує стан авто протягом заряджання на станції та надсилає повідомлення у випадку ненормальинх показників.
3)	Користувачі можуть відправляти запити на обслуговування свого авто прямо через веб-застосунок сервісу і відслідковувати процес виконання цього запиту, або ж скасувати його, якщо не вдається домовитися щодо умов проведення робіт.


1.1.5	Бізнес-ризики


−	Конкуренція: Дана сфера ще є досі новою, і через це багато фірм та стартапів можуть намагатися створити свій продукт, щоб заволодіти нішею. Наявність таких конкурентів може зменшити попит на створений продукт або поставити нові виклики щодо впровадженого функціоналу.
−	Безпека даних: У роботі з клієнтам завжди важливо забезпечити безпеку їхніх даних та даних про їхні авто, оскільки дана інформація, особливо про несправності авто, може знадобитися зловмисникам для скоєння злочинів. Це вимагає залучення команди розробки, що має досвід інтеграції подібних приладів.
−	Виклики реалізації: Програмна система такого тпиу може потребувати широкого спектру інтеграцій існуючими різноманітними засобами обслуговування автомобілів та відслідковування їхнього стану. 
−	Можливі негативні наслідкид для іміджу: Невдала цінова стратегія, неякісно виконані роботи, нечіткі звіти про стан автомобіля, проблеми з користувацьким інтерфейсом можуть сильно вдарити по репутації продукту, особливо на перших стадіях. Критично важливо забезпечити якісно працюючий функціонал у перших випусках, навіть якщо це означатиме, що впровадження нових можливостей потребуватиме більше часу.
−	Швидка зміна індустрії: Зміни в технологіях, що використовуються при створенні електромобілів, потребах користувачів та ринку вимагають їх постійного перегляду, аби сервіс завжди надавав актуальні та якісні послуги.
−	Важлиість залучення обізнаних фахівців у сфері: Важливо залучити професійних механіків для роботи на станціях, аби забезпечити якомога якісніший сервіс та завдяки цьому отримати лояльність потенційних клієнтів.


1.2	Концепція рішення
1.2.1	Окреслення концепції


При створенні системи за мету було взято створення інноваційного, доступного продукту для клієнтів сервісу обслуговування електромобілів, яке стало б для них надійним помічником в обслуговуванні та слідкуванням  за станом. Застосунок має містити дані про автомобіль, історію результатів технічного огляду, надавати рекомендації щодо моніторингу стану авто та попереджувати користувача про необхідність зарядити електромобіль завчано із вказанням найближчої станції. Персонал сервісу може додавати корисний і рекламний матеріал до застосунку, керувати обліковими записами користувачів і отримувати від них зворотний відгук.
Продукт матиме мобільний, IoT та web застосунки, завдяки чому система міцно інтегруватиметься у процеси моніторингу стану електромобіля та безпосередньо процес обслуговування та зарядки.


1.2.2	Головна функціональність


MF1.	Моніторинг відсотку заряду автомобіля:
−	Система вимірює відсоток заряду автомобіля під час користування та, безпосередньо, по мірі заряджання електромобіля. 
−	Результат вимірювань користувач може побачити і під час користування системою.
MF2.	Відстеження аномалій під час зарядки:
−	Користувачі можуть стежити за станом авто під час його зарядки і система, у разі певних аномалій, що можуть виникнути під час заряджання, наприклад перегрів, повідомлятиме про це власника. 
MF3.	Створення та керування запитами на сервісні роботи:
−	Користувач може створити запит на необхідні для його електромобіля послуги та має можливість оновлювати їх кількість за потреби.
−	Робітник сервісу може приймати запити на обслуговування автомобіля, відхиляти їх,  також оновлювати їхній стан.
MF4.	Адміністрування системи:
−	У панелі адміністратора можливо переглядати поточні запити на сервісні послуги та керувати ними, керувати доступом та ролями користувачів до секцій застосунку, керувати станціями тощо.
MF5.	Локалізація та інтернаціоналізація:
−	Система має підтримувати декілька мов для охоплення авдиторії у різних країнах. Більш того, додавання нових мов має впроваджуватися легко і без втручання у безпосередній функціонал.
−	Також мають бути підтримувані різні одиниці виміру, конвертацію у які система має робити на клієнтській частині.


1.2.3	Припущення та залежності


а) Припущення:
−	Припущення, що мають певний рівень обізнаності у автомобільній справі та щодо необхідності регулярного огляду їхніх транспортних засобів зі спеціалістом.
−	Припущення, що в користувачів є доступ до мережі Інтернет та сучасних мобільних пристроїв для користування системою.
−	Припущення, що датчики на смарт-пристрої користувача можуть забезпечувати точні та надійні показники, а підключення до мережі буде забезпечено майже завжди.
б) Залежності:
−	Проєкт є частково залежним від розповсюдженності користування електромобілями у країні, в якій його буде впроваджено у першу чергу, оскільки саме ці люди є потенційною клієнтською базою сервісу.
−	Проєкт залежить від ефективності залучення кваліфікованих механіків, які займатимуться обслуговуванням електромобілів та слідкувати за їхнім станом.
−	Проєкт вимагатиме доступу до  даних від виробників електромобілів для отримання достовірної інформації про стан батарей та їхніх характеристик.


1.3	Рамки та обмеження
1.3.1	Рамки первинного випуску


У проєкті заплановано створення програмного продукту, який матиме як браузерний інтерфейс, так і мобільний застосунок. Браузерний інтерфейс буде зосереджений на адмініструванні та наповненні системи, призначений для працівників і сервісів з обслуговування електромобілів. Мобільний застосунок, навпаки, буде орієнтований на безпосередніх клієнтів, власників електромобілів. У першій версії запуску передбачено наступний функціонал: 
−	Реєстрація облікового запису та вхід за допомогою електронної пошти та пароля. Дані для входу повинні бути зашифровані та захищені від несанкціонованого доступу.
−	Можливість локалізації з легким додаванням нових мов без впливу на функціональність.
−	Адміністрування системи для додавання станцій, нових мов тощо.
Пристрій IoT має надсилати на сервер дані про стан електромобіля під час процесу зарядки. Може повідомляти про перегрів. Також має бути наявна можливість надсилати створені звіти на пошту користувача. До того ж працівник сервісу може змінювати посилання, за яким пристрій звертається до серверної частини.
Система має забезпечувати єдину автентифікацію для браузерної та мобільної версій, з підтримкою ролей для доступу до адміністративної панелі. Адміністративна панель повинна дозволяти надання доступу іншим користувачам.
1.3.2	Рамки наступних випусків


У рамках наступних випусків запланований додатковий функціонал, що має значно розширити можливості застосунку, залучити ще більше користувачів та покращити користувацький досвід впродовж користування ним
−	Можливість побудувати маршрут до найближчої зарядної станції з поточного місцезнаходження.
−	Підписки, що представлятимуть місячнй або річний пакет послуг, що можна регулярно проходити в рамках неї. Існуватиме декілька рівнів підписок. І зі збільшенням ціни користувачам пропонуватиметься ширший спектр послуг, якими вони можуть скористатися на постійній основі.
−	Розширена аналітика для користувачів з підпискою. Подана аналітика дозволить отримувати поради щодо своєчасної заміни чи вчасного обстеження деталей автомобіля.
−	Форум, у якому користувачі зможуть спілкуватися з майстрами сервісних центрів на тему автомобілів. Вони зможуть в режимі онлайн обговорювати теми, які їх цікавлять та ділитися порадами щодо вирішення  проблем, які можуть завадити повноцінному функціонуванню електромобіля.
−	Впровадження функції доповненої реальності, яка допоможе користувачам виявляти та вирішувати проблеми з електромобілем. Користувачі зможуть навести камеру смартфона на частину автомобіля, і застосунок покаже покрокові інструкції з обслуговування чи ремонту.
Заплановані функції будуть впроваджені у майбутніх випусках, що дозволить розширити можливості застосунку і зробити його значно привабливішим для користувачів.


1.3.3	Обмеження та Виключення


Під час реалізації цього продукту існують певні обмеження та виключення, що впливають на розробку і користування застосунком. Важливо врахувати ці фактори для забезпечення коректної роботи застосунку та запобігання проблемам у звичайних користувачів. Серед них:
−	Увесь обмін даними між частинами системи реалізовано через сервер. Це означає, що для повноцінної роботи, кожна з частин має мати стабільне підключення до мережі. Варто забезпечити, щоб усі девайси на станціях знаходилися у одній локальній мережі для забезпечення якомога швидшої взаємодії.
−	Під час проєктування необхідно забезпечити, щоб зарядні станції сумісними з якомога більш великим спектром автомобільних акумуляторів.
З метою забезпечення оптимальної роботи системи в умовах реального використання кінцевими користувачами, адміністратори та користувачі повинні чітко розуміти та враховувати її обмеження та виключення. Також важливо забезпечити коректний зворотній зв’язок, аби повідомляти користувачам про помилки в разі їх виникнення. Ці аспекти є критично важливими для ефективного адміністрування та експлуатації системи, оскільки вони можуть суттєво впливати на її функціональність та загальну продуктивність.


1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


На таблиці 1 описані профілі зацікавлених сторін:

Таблиця 1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Власники електромобілів	Слідкування за станом свого авто, своєчасні технічні огляди, якість обслуговування та швидкість процесу зарядки електромобіля.	Позитивне, якщо застосунок допоможе збільшити ефективність взаємодії з автосервісом та зможе спростити обслуговування автомобіля та отримання сервісних послуг.	Отримання актуальних даних про стан електромобіля під час заряджання, можливість відправлення запитів про необхідну послугу безпосередньо до сервісу.	Через те, що електромобілі можуть мати різні характеристики, вони можуть потребувати різних умов та інструментів для їх обслуговування.
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Власники сервісних центрів	Розширення клієнтської бази сервісних станцій для підвищення прибутку	Позитивне, якщо продукт зможе залучити більше нових клієнтів до сервісних центрів і виділити їх на фоні конкурентів.	Стимулювання лояльності користувачів, збільшення прибутків від виконання сервісних робіт 	Нестача коштів, особливо на етапі запуску, зумовлює потребу в ретельному аналізі та розставленні пріоритетів вимог для подальшого розширення команди розробників.
Учасники команди розробки	Здатність підтримувати чистоту коду та досвід у сфері проектування та розробки застосунків.	Позитивне, при чітких вимогах до продукту, актуальній документації та злагодженому, організованому процесі розробки.	Досвід розробки застосунків у сфері обслуговування, можливість слідкувати за станом авто за рахунок інтеграцій	Неузгодженість між термінами, встановленими замовниками, та заявленими вимогами може призвести до негативного впливу на його якість.
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Бізнес-партнери	Підвищення зацікавленості потенційних клієнтів у їхніх деталях та інших продуктах за рахунок реклами та їх використання у сервісі.	Позитивне, якщо створена система допоможе підвищити продажі їхніх товарів, отримати нових лояльних покупців та збільшити загальні прибутки.	Можливість просувати власні товари серед клієнтів автосервісу за допомогою застосунку та спеціальних пропозицій.	Важкість просування товарів від нових та невідомих користувачам компаній та велика конкуренція з боку інших постачальників, які також пропонують свій товар у застосунку.


1.4.2	Пріоритети проєкту


На таблиці 2 наведені основні пріоритети проєкту:

Таблиця 2 – Основні пріоритети проєкту 
Показник	Опис	Пріоритет
План робіт	Випуск версії 1.0 має бути доступний до 31.05.2024.	Високий
Функціональність	Версія 1.0 повинна мати всі функції, описані в специфікації.	Високий
Якість	Система має бути надійною, стійкою до помилок та доступною цілодобово.	Високий
Персонал	Команда розробників на початковому етапі буде представлена однією людиною.	Середній
Ціна	Фінансування початкової версії продукту є невеликим та за потреби може бути збільшено на 10%.	Середній


1.4.3	Робоче середовище


Програмна система подібного масштабу вимагає ретельного підібрання технологій, що будуть використані для її розробки. Внаслідок аналізу досвіду команди розробки та поточних трендів у розробці, було обрано наступний перелік технологій:
−	Розробка клієнтської браузерної частини та серверної частини буде проведена за допомогою мови TypeScript. Маючи спільну мову для цих двох частин, стає значно легше забезпечити консистентність даних та типів, а також вносити зміни в одну частину після редагування іншої.
−	Для створення серверної частини буде використано фреймворк NestJS. Даний фреймворк довзоляє найкраще застосувати можливості TypeScript для створення чистої та легкопідтримуваної кодової бази, а також забезпечити реаліацію наскрізної функціональності та наслідування кращих архітектурних шаблонів.
−	В якості СКБД буде використана PostgreSQL, як один з найпопулярніших поточних виборів у сфері реляційних баз даних.
−	Для створення користувацького інтерфейсу буде використано бібліотеку ReactJS, аби забезпечити швидкість, інтерактивність інтерфейсу, структурність коду та компонентів, при цьому зберігаючи чудову швидкодію створеного ПЗ.
−	Для створення мобільного застосунку буде застосована мова програмування Kotlin. Розробка буде проведена лише під операційну систему Android, зважаючи на обмеження нативної розробки під iOS. 
−	Для IoT-девайсу буде використано платформу ESP32, оскільки вона підтримує під’єднання до мережі, а також є дуже компактною і легкою в експлуатації.
−	Будуть використані найкращі практики для автентифікації та авторизації користувачів, аби забезпечити безпеку даних у системі.
−	Доступність та надійність: Система буде розгорнута на віддаленому сервері для можливості цілодобового доступу без значних перерв у роботі.
 
2	ПРОЄКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ
2.1	Опис архітектури системи


Перед безпосередньої розробкою системи необхідно прийняті критично важливі рішення щодо архітектурних підходів, що будуть застосовані протягом розробки та з яких частин система складатиметься.
Запланована система має складатися з чотирьох компонентів: безпосередньо браузерного та мобільного клієнтів, IoT-пристрою, що являє собою просунутий засіб для заряджання автомобілів, та серверної частини, що буде слугувати джерелом даних для клієнтських частин та смарт-девайсу.
Браузерний застосунок слугуватиме як засобом для звичайним користувачів системи, так і знадобиться її адміністраторам для керування нею.
Мобільний застосунок орієнтований на клієнтів, власників електромобілів, оскільки в ньому вони сможуть керувати своїми машинами та переглядати історію заряджнань.


2.2	Побудова діаграми розгортання


Розгортання системи є одним з найважливіших аспектів створення масштабованої та надійної системи, що надаватиме свої послуги на постійній основі. Правильно проведене розгортання забезпечує стійкий розвиток для системи та можливість її розробникам впроваджувати кращий, корисніший функціонал, віддаючи значно більше уваги його якості. Саме то було важливо в першу чергу змоделювати майбутнє розгортання створюваної системи.
В даному випадку, планується розгорнути серверну частину разом із базою даних у хмарі, аби забезпечити безперебійний цілодобовий доступ до них та покращити їх безпеку.
З огляду на вищевикладене, було прийнято розгорнути серверну частину та базу даних у хмарному середовищі для забезпечення безпеки даних та безперебійної роботи ключових частин системи.
Для взаємодії із серверною частиною планується використовувати HTTPS з’єднання, аби забезпечити шифрування даних. Для цього буде отримано SSL сертифікат.
IoT девайс та мобільний застосунок являють собою програмне забезпечення, що буде встановлено на відповідні пристрої.
Браузерний застосунок являтиме собою зібрані статичні файли, що надсилатимуться клієнту з веб-серверу для подальшої обробки інтерфейсу у браузері користувача.
Для демонстрації складного процесу розгортання системи була створена відповідна діаграма, що наведена у додатку А.1.
 
3	РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
3.1	Опис архітектури серверної частини системи


Спираючись на використовувані технології та загальноприйняті підходи, було прийнято рішення використовувати N-рівневу архітектуру. Це дозволить забезпечити якісне розділення коду, велику масштабоаність, конфігурованість, а також спрощує внесення змін до кодової бази, оскільки зміни в одному шарі не мають вимагати зміни функціональності в інших. В даному випадку було виокремлено три шари: шар представлення, шар бізнес-логіки та шар доступу до даних.
Шар доступу до даних маніпулює необробленими даними з бази даних та загалом слугує саме для створення запитів до бази даних, результати яких будуть оброблені у наступному шарі. У проєкті даний шар буде реалізовано за допомогою бібліотеки TypeORM, що пропонує звіт готовий функціонал репозиторіїв для створених сутностей.
Шар бізнес-логіки реалізовано у вигляді класів-сервісів, що містять методи для отримання готових оброблених даних. Цей шар містить більшу частину логіки усього додатку, маніпулює вхідними даними з запиту та даними, що були отримані з шару доступу до даних.
Шар представлення відповідає за обробки запитів до серверу та слугує вхідною точкою до нього. На цьому шарі викликаються відповідні методи сервісів, а також виконуються маніпуляції із об’єктами запитів та відповідей серверу, наприклад встановлюються певні заголовки. У даному проєкті цей шар буде реалізовано за допомогою класів-контролерів, кожен з методів яких є однією, чітко окресленою точкою входу у серверну частину



3.2	Побудова діаграми прецедентів для серверної частини системи


Запланована система має три ролі: звичайний користувач, працівник станції для обслуговування та адміністратор. З огляду на оце, проведемо детальне концептуальне моделювання для розуміння того, який функціонал треба впровадити для тієї чи іншої ролі.
Клієнт має доступ до мобільної частини, у якікй він може обрати активний автомобіль, що буде використовуватися під час заряджання, переглядати історію заряджань та аномальних значень, що були помічені протягом них. Також для нього буде доступний браузерний застосунок, у якому він може керувати своїми запитами на сервісні послуги, а також створювати нові, вказуючи одне зі своїх авто. 
Працівникам потрібно в першу чергу мати доступ до поточних запитів на сервісні послуги для їх станцій. Саме це буде їм надано через веб-застосунок.
Для адміністраторів важливо мати якнайібільше контролю над системою. Для контролю прав користувачів адміністратори матимуть окремий розділ у браузерному ПЗ, як і для керування наявними у системі станціями.
Детальніше вищевикладене було проілюстровано на діаграмі прецедентів, що наведена у додатку А.2.


3.3	Побудова ER-діаграми для серверної частини системи


Внаслідок детального аналізу предметної області та проведення концептуального моделювання системи, можемо виділити наступні сутності, якими вона буде оперувати:
•	Сутнність «Користувач» –;сутність, що містить дані про обліковий запис користувача, його refresh token і тощо;
•	Сутнність «Автомобіль» – містить інформацію про автомобіль, що належить певному користувачу;
•	Сутнність «Заряджання» – містить інформацію про сесію заряджання, що проводилася на певній станції із певним автомобілем;
•	Сутнність «Станція» – містить інформацію про сервісну станцію для власників електомобілів;
•	Сутнність «Інцидент» – містить інформацію про абнормальне значення, що було помічено протягом певного заряджання автомобіля.
•	Сутнність «Запит на сервісні послуги» – містить дані про сервісні послуги, що були замовлені у певної станції для певного автомобіля. Містить свій статус.
На основі поданих сутностей була сформована ER (Entity Relationship) діаграма, що наведена у додатку А.3


3.4	Специфікація REST


На основі наявних сутностей наведемо специфікацію REST для створюваною програмної системи.
Автентифікація:
•	POST auth/sign-up – створення нового облікового запису безпосередньо незареєстроваим користувачем;
•	POST auth/sign-in – вхід у обліковий запист за поштою та паролем.
•	POST auth/refresh – здійнсює перевипуск пари токенів для авнетифікація для того, щоб оновити їх, коли термін їх дійсності спливає.
Облікові записи:
•	GET users/ – отримання інформації про обліковий запис користувача за індентифікатором;
•	POST users/ – створення нового користувача;
•	GET users/employees – отримання усіх працівників у системі;
•	GET users/:id – отримання інформації про обліковий запис користувача за індентифікатором;
•	PATCH users/:id – зміна інформації про обліковий запис користувача за індентифікатором;
•	DELETE users/:id – видалення облікового запису користувача за індентифікатором.
Машини:
•	POST cars/ – створення нового автомобіля для користувача;
•	GET cars/ – отримання усіх автомобілів користувача, що няавні у системі;
•	POST cars/:id/set-active –встановлення певного автомобіля як активного;
•	GET cars/active – отримання активного автомобіля користувача, що буде використовуватися під час заряджань. Якщо немає, то повертає null;
•	GET cars/:id– Отримання автомобіля за його ідентифікатором;
•	PATCH cars/:id – зміна інформації про певний автомобіль за його унікальним ідентифікатором;
•	DELETE cars/:id – видалення певного автомобіля за його унікальним ідентифікатором.
Заряджання:
•	POST chargings/ – початок нового заряджання по ідентифікатору машини та станції;
•	GET chargings/ –  отримання усіх сесій зарядки користувача;
•	GET chargings/:id – отримання певного заряджання користувача по ідентифікатору заряджання;
•	PATCH chargings/ – редагування певного заряджання.
•	Станції
•	POST stations/ – створення нової станції;
•	GET stations/ – отримання усіх наявних у системі станцій;
•	GET stations/:id – отримання певної станції по її ідентифікатору;
•	PATCH stations/:id – редагування певної станції по її ідентифікатором;
•	DELETE stations/:id – видалення певної стації, що наявна у системі за її ідентифікатором.
Запити на сервісні послуги
•	POST maintenance-requests/ – створення нового запиту на сервісні послуги;
•	GET maintenance-requests/ – отримання усіх запитів на сервісні послуги. Адміністратор отримує усі запити, користувач – тільки його власні, а працівник тільки ті, що були зроблені до його станції.
•	GET maintenance-requests/:id – отримання певного запиту на сервісні послуги по його ідентифікатору;
•	PATCH maintenance-requests/:id – редагування запиту на сервісні послуги, зокрема статусу;
•	DELETE maintenance-requests/:id – видалення певного запиту на сервісні послуги.
Інциденти
•	POST incidents/ – створення нового інциденту для заряджання;
•	GET incidents/ – отримання усіх інцидентів певного заряджання окремо від заряджання.
3.5	Побудова діаграми пакетів для серверної частини системи


У застосунках, створених за допомогою фреймворку NestJS, зазвичай застосунки розділені на окремі модулі, кожен з яких відповідає за взаємодію із певною сутністю, або за певну окрему бізнес-логіку. Наслідуючи цю практику, пакети створеного проєкту здебільшого представляють собою те, які сутності наявні у ньому. У кореневому пакеті app відбувається конфігурація усіх наявних у застосунку модулів, а також підключення необхідних динамічних модулів з необхідними для них даними.
Серед пакетів для сутностей є наступні: car, charging, incident, user, car, station.
Також присутній пакет auth, що відповідає за автенифікацію на основі JWT-токенів та авторизацію.
Більш того, пакети зазвичай містять підпакети, що містять функціональність, яку зручно використовувати у межах модуля та поза ним. Серед таких:
•	guards – класи, що представляють частину наскрізної функціональність застосунку та керують доступ до певних ресурів;
•	entities – класи-сутності, що стосуются даного модуля;
•	decorators – спеціальні функції, що дозволяють додавати до класів, їх методів та аргументів цих методів певні метадані, а також використовувати механізм Dependency Injection.
Детальніше те, з яких пакетів складається проєкт було відображено на діаграмі пакетів, що наведена у додатку А.4.
 
4	РОЗРОБКА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ ВБУДОВАНИХ СИСТЕМ
4.1	Концептуальне моделювання системи


Перш ніж розпочати розробку платформи для вбудованих систем, важливо створити концептуальну модель програмного продукту. 
При виборі мікроконтролера, на якому буде базуватися платформа, необхідно врахувати всі вимоги, включаючи ключову можливість підключення до Wi-Fi мережі для взаємодії із сервером. Дуже важливо врахувати саме цей фактор у першу чергу, оскільки робота пристрою безпосередньо пов’язана з обміном даними із серверною частиною.
Контролер має по-перше вимагати у користувача підтвердити свою особистість шляхом автентифікації. Далі, якщо користувач не є адміністратором пропонувати почати зарядання автомобіля. Також він має перевіряти чи обрав користувач активний автомобіль у мобільному застосунку та сповіщати про його відсутність. Протягом заряджання, якщо батарея перевищує певне граничне значення, девайс має записувати в історію сповіщення про перегрівання. При затисканні кнопки заряджання або досягненні максимального рівня заряду, девайс має самостійно закінчувати заряджання, сповіщуючи про це сервер.
Якщо користувач є адміністратором, окрім функціоналу заряджання, він також повинен мати можливість змінювати посилання, за яким IoT-девайс звертається до серверної частини.
У відповідності до вищезазначеного, була розроблена UML діаграма прецедентів у додатку А.5



4.2	Опис розробки застосунку для вбудованих систем
4.2.1	Обґрунтування архітектурних рішень проєкту


При розробці програмного забезпечення длу вбудованих систем було обрано наслідувати принципи монолітної архітектури, з огляду на специфіку та обсяги створюваного проєкту. Таким чином була забезпечена швидка розробка, зважаючи на простоту даного підходу, а також швидкий обмін даними між складовими системи.
Пристрій починає свою роботу з обов’язкового підключення до мережі і не продовжує свою роботу поки воно не буде встановлено, оскільки це є ключем до його роботи. Взаємодія з сервером відбувається за допомогою HTTP-запитів за заздалегідь заданим шляхам. За взаємодію з сервером, як і за решту функціоналу відповідають окремі класи-сервіси.
Для коректної роботи пристрою також вимагається автентифікація, оскільки девайс потребує інформацію про активну машину користувача, аби записувати історію заряджань та аномальних показників.
Для детальнішої демонстрації описаних процесів була мстворена UML діаграма взаємодії у додатку А.6.


4.2.2	Опис використаних технологій


Серцем створеного програмного забезпечена стала платформа ESP32, оскільки вона забезпечує найважливіший аспект його роботи – підключення до інтернету. Розробка була проведена за допомогою веб-симулятору Wokwi. В якості мови програмування було використано MicroPython.
Окрім мікроконтролеру були використано додаткові частини, завдяки яким був реалізований безпосередній функціонал. Кнопка відповідає за початок та кінець заряджання. Світлодіод сповіщає про те, чи відбувається заряджання. Потенціометр відповідає за симуляцію підвищення сили струму, що подається при заряджанні, оскільки у симуляторі неможливо задіяти справжні джерела струму.


4.2.3	Опис результатів розробки частини проекту для вбудованих систем


Результатом проведеної розробки є програмне забезпечення, інтегроване у систему обслуговування власників електромобілів. Реалізація передбачає використання мікроконтролер ESP32, як платформи, на які буде працювати створене ПЗ.
Робота з пристрою починається з підключення до мережі та автентифікації користувача для ідентифікації дій, які він може робити із ним, а також отримання даних про активне авто, що надалі буде заряджатися.
Якщо користувач є звичайним клієнтом, то після автентифікації його буде переведено безпосередньо до одного функціоналу, що йому доступний – заряджання автомобілю. Пристрій робить запит на сервер для отримання активного автомобілю користувача, аби коректно записати майбутнє заряджання в історію. Якщо активний автомобіль відсутній, користувачеві буде показано відповідне повідомлення з проханням обрати активний автомобіль та підтвердити продовженя роботи із пристроєм. Як тільки пристрій отримує дані про активний автомобіль він починає заряджати автомобіль. Доступна зміна сили струму, що подається на автомобіль, що відповідно впливатиме на швидкість заряджання, але також може значно підвищити температуру батареї. Кожне зчитування стану заряджання також зчитує температуру батереї та при перегріванні на сервер буде надіслано відповідне сповіщення, що буде збережно в історії поточного заряджання. Заряджання можна закінчити за допомогою відповідної кнопки на пристрої, або зачекавши поки рівень зарядки батареї досягне максимального. При закінченні заряджання, його статус на сервері змінюється на закінчене, а також зберігається кінцевий відсоток зарядки.
Якщо ж користувач не є звичайним клієнтом, а працівником або адміністратором, то при початку роботи із пристроєм йому буде доступна можливість конфігурації взаємодії із сервером. У даному меню користувач може змінити посилання, за яким девайс звертатиметься до нього.
Для детальнішої демонстрації принципу роботи створеного програмного забезпечення для IoT пристрою наведено в UML діаграмі станів у додатку А.7.


4.2.4	Опис результатів тестування частини проекту для вбудованих систем


Для того, щоб забезпечити надійність, зручність та правильність роботи частини для вбудованих систем було проведено її функціональне тестування, з використанням веб-симулятора Wokwi. Протягом нього була перевірена ключова функціональність застосунку, безпека даних та взаємодія із сервером.
Згідно з результатами тестування значних недоліків знайдено не було.
 
5	РОЗРОБКА КЛІЄНТСЬКОГО ВЕБ-ЗАСТОСУНКУ
5.1	Концептуальне моделювання системи


Перед безпосередньою розробкою програмного продукту важливо провести детальне його детальне концептуальне моделювання.
Браузерний веб-застосунок, що має стати результатом проведеної розробки, має бути доступний для усіх трьох ролей системи: клієнта, працівника сервісу та адміністратора. Першим двом має бути доступна можливість керувати запитами на сервісні послуги, власні, або ж ті, що стосуються відповідної станції у випадку працівника. Для адміністратора ж мають бути також доступні можливості керування правами користувачів, а також наявними у системі станціями.
Тобто застосунок також має підтримувати автентифікацію та авторизацію для того, щоб чітко розрізнювати користувачів за їх ролями та можливостями.
Взявши до уваги усі можливі ролі у застосунку та який функціонал їм доступний була сформована UML  діаграма прецедентів, що наведена у додатку А.9.


5.2	Опис розробки клієнтського веб-застосунку
5.2.1	Обґрунтування архітектурних рішень проєкту


Взявши до уваги останні тренди розробки клієнтських застосунків, міркувань підтримуваності, розширюваності та реактивності протягом створення були наслідувані принципи компонентно-орієнтованої архітектури.
Такий підхід дозволить легко перевикористовувати окремі напівзалежні компоненти у створюваному інтерфейсі, створювати спільну логіку та наповнювати застосунок інтерактивним функціоналом із малими витратами по швидкодії за рахунок оновлень лише тих частин, що потребують цього. Більш того, подібний код значно легше тестувати за рахунок ізольованості компонентів.
Застосунок має підтримувати локалізацію. Більш того, має бути можливість простої інтеграції нових перекладів за рахунок додавання нових статичних файлів із ними для відповідних мов.
Взаємодія з сервером відбувається за допомогою HTTP-запитів, що здійснюються до визначених вхідних точок серверної частини. Більша частина стану застосунку залежить від даних, що зберігає та надсилає сервер.
Автентифікація у застосунку базується на access та refresh токенах, що містять у собі інформацію про користувача та мають обмежений термін придатності, за рахунок чого значно зменшуються можливі негативні наслідки при потраплянні токену у руки зловмисників.
Для кращої демонстрації архітектурних рішень, що були прийняті при проєктуванні системи, була створена UML діаграма компонентів, що наведена у додатку А.10.


5.2.2	Опис використаних технологій


Основої розробки стала бібліотека ReactJS із використанням мови програмування TypeScript. Дана бібліотека довзоляє створювати швидкі, інтерактивні інтерфейси на основі численних компонентів, що перевикористовуються, застосовуючи декларативний підхід.
Локалізація реалізована за допомогою i18next та react-i18next, а також використовується i18next-http-backend для завантаження перекладів безпосередньо з серверу.
Щоб детальніше продемонструвати залежності системи була створена UML діаграма пакетів, що наведена у додатку А.11.


5.2.3	Опис результатів розробки клієнтського веб-застосунку


Результатом розробки браузерної клієнтською частини став застосунок, написаний на ReactJS, що дозволяє користувачам програмної системи створювати запити на сервісні послуги для їх машин, працівникам сервісу обробляти ці записи, а адмінстраторам автосервісів керувати доступами користувачів системи до функціоналу та даних, а також керувати станціями.
При вході на сайт, користувач потрапляє на екран входу в обліковий запис. З нього він може також перейти на екран реєстрації, якщо він ще не зареєстрований. Після реєстрації користувач автоматично стає автоматично автентифікований і потрапляє на основну сторінку саме так, як і при звичайному вході в акаунт.
Усього застосунок розбитий на 3 основні вкладки, навігаціями якими здійснюється за допомою відповідних кнопок вгорі сторінок застосунку, а саме «Запити на послуги», «Працівники» та «Станції», а також містить сторінки автентифікації та ресєстрації.
Детальніше робота браузерного клієнту описана за допомогою діаграми діяльності, що наведена у додатку А.12.






5.2.4	Опис результатів тестування клієнтського веб-застосунку


Для того, щоб забезпечити надійність, зручність та правильність роботи частини браузерного веб-застосунку було проведено його функціональне тестування. Середовищем тестування став браузер Google Chrome. Протягом нього була перевірена ключова функціональність застосунку, безпека даних та взаємодія із сервером.
Згідно з результатами тестування значних недоліків знайдено не було.
 
ВИСНОВКИ


Починаючи розробку системи, було проведено початкове концептуальне моделювання, завдяки якому був визначений головний функціонал створюваного ПЗ, детально проаналізовані вже наявні на ринку рішення, бізнес-можливості та бізнес-ризики, що можуть виникнути на шляху реалізації проєкту.
За допомогою діаграм було детально описано процес розгортання системи, наявні у ній сутності та зв’язки між ними. Був визначений архітектурний підхід протягом проєктування серверної частини та які технології будуть використані для неї та інших частин. Також, для серверної частини була наведена специфікація REST та детальний опис пакетів, з яких вона складається.
Врахувавши вимоги до мікроконтролеру, під який буде проведена розробка ПЗ для смарт-девайсу, було обрано платформу ESP32, оскільки вона є дуже компактною, підтримує підключення до мережі та може виконувати програми, написані мовою MicroPython. 
В якості браузерного застосунку було реалізовано панель для звичайних користувачів, завдяки якій можливо проводити адміністрування системи, а також створювати, переглядати, оновлювати запити на сервісні роботи.
Для смарт-девайсу та браузерної частини було проведено окреме детальне концептуальне моделювання, описана архітектура створюваного ПЗ, використані технології та результати розробки.
 
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ


•	NestJS Authentication. NestJS. URL: https://docs.nestjs.com/security/authentication (дата звернення 24.06.2024)
•	Репозиторій з кодом курсового проєкту. URL: https://github.com/NureMatiushenkoIryna/apzkr-pzpi-21-10-matiushenko-iryna (дата звернення 24.06.2024)
•	Методичні вказівки до курсової роботи з навчальної дисципліни «Архітектура програмного забезпечення» для студентів усіх форм навчання спеціальності 121 – «Інженерія програмного забезпечення» [Електронне видання] / Упоряд. В.О. Лещинський, І.О. Лещинська, І.П. Сокорчук – Харків: ХНУРЕ, 2021. – 37 с.
•	Getting Started. Vite. URL: https://vitejs.dev/guide/ (дата звернення 24.06.2024)
•	ESP32 Simulation Docs. Wokwi. URL: https://docs.wokwi.com/guides/esp32 (дата звернення 24.06.2024)
•	Zustand Documentation. PMNDRS. URL: https://docs.pmnd.rs/zustand/getting-started/introduction (дата звернення 24.06.2024)
•	Відеозапис демонстрації роботи системи. URL: https://youtu.be/EWDubfZ6QLY (дата звернення 24.06.2024)
 
ДОДАТОК А
UML Діаграми

А.1 UML діаграма розгортання системи

 
Рисунок А.1 – UML діаграма розгортання системи
А.2 UML діаграма прецедентів серверної частини

 
Рисунок А.2 – UML діаграма прецедентів серверної частини





А.3 ER-діаграма

 
Рисунок А.3 – ER-діаграма
 
А.4 UML діаграма пакетів серверної частини

 
Рисунок А.4 – UML діаграма пакетів серверної частини
 
А.5 UML діаграма прецедентів частини для вбудованих систем

 
Рисунок А.5 – UML діаграма прецедентів частини для вбудованих систем
 
А.6 UML діаграма взаємодії частини для вбудованих систем

 
Рисунок А.6 – UML діаграма взаємодії частини для вбудованих систем

А.7 UML діаграма станів частини для вбудованих систем

 
Рисунок А.7 – UML діаграма станів частини для вбудованих систем

А.8 Схема фіізичної моделі частини для вбудованих систем

 
Рисунок А.8 – Схема фіізичної моделі частини для вбудованих систем
 
А.9 UML діаграма прецедентів браузерного клієнту

 
Рисунок А.9 – UML діаграма прецедентів браузерного клієнту
 
А.10 UML діаграма компонентів браузерного клієнту

 
Рисунок А.10 – UML діаграма компонентів браузерного клієнту
 
А.11 UML діаграма пакетів браузерного клієнту

  Рисунок А.11 – UML діаграма пакетів браузерного клієнту
 
А.12 UML діаграма діяльності браузерного клієнту

 
Рисунок А.12 – UML діаграма діяльності браузерного клієнту
 
ДОДАТОК Б
Фрагменти коду

Б.1 Код Guard-класу для авторизації користувачів по ролях

1    import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
2    import { Reflector } from '@nestjs/core';
3    import { Request } from 'express';
4    import { UserRole } from '../enums/user-role.enum';
5    import { JwtData } from '../decorators/types/jwt-data.type';
6    
7    @Injectable()
8    export class RolesGuard implements CanActivate {
9      constructor(private readonly reflector: Reflector) {}
10   
11     canActivate(context: ExecutionContext): boolean {
12       const rolesPermitted = this.reflector.get<UserRole[]>(
13         'roles',
14         context.getHandler(),
15       );
16   
17       if (!rolesPermitted) {
18         return true;
19       }
20   
21       const request = context.switchToHttp().getRequest() as Request;
22       const data = request.user as JwtData;
23       return rolesPermitted.includes(data.user.role);
24     }
25   }



Б.2 Код контролеру для запитів на сервісні послуги

1    import {
2      Controller,
3      Get,
4      Post,
5      Body,
6      Patch,
7      Param,
8      Delete,
9      UseGuards,
10     Query,
11     Req,
12   } from '@nestjs/common';
13   import { MaintenanceRequestService } from './maintenance-request.service';
14   import { CreateMaintenanceRequestDto } from './dto/create-maintenance-request.dto';
15   import { UpdateMaintenanceRequestDto } from './dto/update-maintenance-request.dto';
16   import { ApiBearerAuth, ApiQuery, ApiTags } from '@nestjs/swagger';
17   import { AuthGuard } from 'src/auth/guards/auth.guard';
18   import { UserRole } from 'src/auth/enums/user-role.enum';
19   import { UserId } from 'src/auth/decorators/userid.decorator';
20   import { Request } from 'express';
21   import { JwtData } from 'src/auth/decorators/types/jwt-data.type';
22   
23   @ApiBearerAuth()
24   @ApiTags('maintenance-requests')
25   @UseGuards(AuthGuard)
26   @Controller('maintenance-requests')
27   export class MaintenanceRequestController {
28     constructor(
29       private readonly maintenanceRequestService: MaintenanceRequestService,
30     ) {}
31   
32     @Post()
33     create(@Body() createMaintenanceRequestDto: CreateMaintenanceRequestDto) {
34       return this.maintenanceRequestService.create(createMaintenanceRequestDto);
35     }
36   
37     @ApiQuery({
38       required: false,
39       name: 'page',
40     })
41     @ApiQuery({
42       required: false,
43       name: 'perPage',
44     })
45     @Get()
46     findAll(
47       @UserId() userId: string,
48       @Req() request: Request,
49       @Query('page') page?: number,
50       @Query('perPage') perPage?: number,
51     ) {
52       const { user } = request.user as JwtData;
53       switch (user.role) {
54         case UserRole.Admin:
55           return this.maintenanceRequestService.findAll(page, perPage);
56         case UserRole.Customer:
57           return this.maintenanceRequestService.findAllRequestsByUser(
58             page,
59             perPage,
60             userId,
61           );
62         case UserRole.Employee:
63           return this.maintenanceRequestService.findAllRequestsByStation(
64             page,
65             perPage,
66             user.stationId,
67           );
68       }
69     }
70   
71     @Get(':id')
72     findOne(@Param('id') id: string) {
73       return this.maintenanceRequestService.findOne(id);
74     }
75   
76     @Patch(':id')
77     update(
78       @Param('id') id: string,
79       @Body() updateMaintenanceRequestDto: UpdateMaintenanceRequestDto,
80     ) {
81       return this.maintenanceRequestService.update(
82         id,
83         updateMaintenanceRequestDto,
84       );
85     }
86   
87     @Delete(':id')
88     remove(@Param('id') id: string) {
89       return this.maintenanceRequestService.remove(id);
90     }
91   }


Б.3 Код сервісу для автентифікації за допомогою JWT токенів

1    import { BadRequestException, Injectable } from '@nestjs/common';
2    import { JwtService } from '@nestjs/jwt';
3    import { hash, compare } from 'bcrypt';
4    import { UserService } from 'src/user/user.service';
5    import { User } from 'src/user/entities/user.entity';
6    import { SignInDTO } from './dto/sign-in.dto';
7    import { SignUpDTO } from './dto/sign-up.dto';
8    import { JwtData } from './decorators/types/jwt-data.type';
9    
10   @Injectable()
11   export class AuthService {
12     constructor(
13       private userService: UserService,
14       private jwtService: JwtService,
15     ) {}
16   
17     async signUp(data: SignUpDTO) {
18       const userDto = await this.userService.create(data);
19       const user = await this.userService.findOne(userDto.id);
20   
21       const { accessToken, refreshToken } = this.generateTokensPair(user);
22   
23       user.refreshToken = await hash(refreshToken, 10);
24   
25       await this.userService.update(user.id, user);
26   
27       return {
28         accessToken,
29         refreshToken,
30       };
31     }
32   
33     async signIn(data: SignInDTO) {
34       const existingUser = await this.userService.findOneByEmail(data.email);
35   
36       if (!existingUser) {
37         throw new BadRequestException('No such user exists');
38       }
39   
40       const passwordMatch = await compare(data.password, existingUser.password);
41   
42       if (!passwordMatch) {
43         throw new BadRequestException('No such user exists');
44       }
45   
46       const { accessToken, refreshToken } = this.generateTokensPair(existingUser);
47   
48       existingUser.refreshToken = await hash(refreshToken, 10);
49   
50       await this.userService.update(existingUser.id, existingUser);
51   
52       return {
53         accessToken,
54         refreshToken,
55       };
56     }
57   
58     async refresh(refreshToken: string) {
59       const tokenData = this.jwtService.decode(refreshToken) as JwtData;
60   
61       const existingUser = await this.userService.findOne(tokenData.userId, true);
62   
63       if (!existingUser) {
64         throw new BadRequestException('No user matches the provided credentials');
65       }
66   
67       const tokensPair = this.generateTokensPair(existingUser);
68   
69       existingUser.refreshToken = await hash(tokensPair.refreshToken, 10);
70   
71       await this.userService.update(tokenData.userId, existingUser);
72   
73       return tokensPair;
74     }
75   
76     private generateTokensPair(user: User) {
77       const { id, ...rest } = this.getSafeUser(user);
78   
79       const jwtPayload = { sub: id, data: rest };
80   
81       const accessToken = this.jwtService.sign(jwtPayload, {
82         secret: process.env['ACCESS_SECRET'],
83         expiresIn: `${process.env['ACCESS_EXPIRATION_TIME']}s`,
84       });
85   
86       const refreshToken = this.jwtService.sign(jwtPayload, {
87         secret: process.env['REFRESH_SECRET'],
88         expiresIn: `${process.env['REFRESH_EXPIRATION_TIME']}s`,
89       });
90   
91       return { accessToken, refreshToken };
92     }
93   
94     private getSafeUser(user: User): Omit<User, 'password' | 'refreshToken'> {
95       const { password, refreshToken, ...rest } = user;
96   
97       return rest;
98     }
99   }


Б.4 Код головного сервісу програмного забезпечення для вбудованих систем

1    class AppService:
2        def __init__(self):
3            self.api_service = ApiService()
4            self.netword_service = NetworkService()
5            self.login_service = LoginService()
6    
7        def read_current(self):
8            sensor_value = potentiometer.read()
9            current = (sensor_value / 4095.0) * 20
10           return current
11   
12       def read_temperature(self):
13           sensor_value = potentiometer.read()
14           print(sensor_value / 4095.0 * 30)
15           return random.uniform(20.0, 20 + (sensor_value / 4095.0 * 30))
16   
17   
18       def charge(self):
19           global charging, state_of_charge, temperature
20   
21           startPercent = random.randint(0, 20)
22           state_of_charge = startPercent
23           self.api_service.start_charging(startPercent)
24   
25           while True:
26               turnedOff = False
27               if button.value() == 1:
28                   turnedOff = True
29                   charging = not charging
30                   time.sleep(0.5)
31   
32               if charging:
33                   if state_of_charge == 0:
34                       state_of_charge = random.randint(0, 20)
35                   current = self.read_current()
36                   state_of_charge += current * 0.1
37                   state_of_charge = min(state_of_charge, 100)
38   
39                   temperature = self.read_temperature() 
40                   
41                   power = current * voltage
42   
43                   if temperature > constants.OVERHEAT_THRESHOLD:
44                       self.api_service.send_incident(temperature, "overheat", "The car was overheated")
45               
46                   print('EV Charging Monitor', 0, 0)
47                   print(f'Voltage: {voltage:.2f}V', 0, 10)
48                   print(f'Current: {current:.2f}A', 0, 20)
49                   print(f'Power: {power:.2f}W', 0, 30)
50                   print(f'State of Charge: {state_of_charge:.2f}%', 0, 40)
51                   print('Status: Charging' if charging else 'Status: Not Charging', 0, 50)
52                   print(f'Temperature: {temperature:.2f}C', 0, 50)
53   
54                   if state_of_charge == 100:
55                       charging = False
56                       self.api_service.finish_charging(state_of_charge)
57                       print("Thank you for using our charging service!")
58                       state_of_charge = 0
59                       break
60               elif turnedOff:
61                   self.api_service.finish_charging(state_of_charge)
62                   print("Thank you for using our charging service!")
63                   state_of_charge = 0
64                   break
65   
66               led.value(charging)
67               time.sleep(1)
68   
69   
70       def prepare_charge(self):
71           self.verify_active_car()
72           self.charge()
73   
74   
75       def configure(self):
76           url = input("Enter the URL to change to: ")
77           constants.API_URL = url
78           print("Changed!")
79   
80       
81       def verify_active_car(self):
82           print("Waiting for the car to be plugged in. Please confirm when it's ready.")
83           input()
84           hasActiveCar = self.api_service.get_active_car()
85           if not hasActiveCar:
86               print("No active car selected. Please choose it in the app and confirm again.")
87               return self.verify_active_car()
88           print("Got active car")
89   
90   
91       def main(self):
92           global charging, state_of_charge
93           self.netword_service.connect_to_wifi()
94           print("Welcome to our station! Please sign in.")
95           self.login_service.sign_in()
96           while True:
97               print("What would you like to do?")
98               print("1 - Charge my active car")
99               print("2 - Change server URL")
100              action = int(input())
101              if action == 1:
102                  self.prepare_charge()
103              elif action == 2:
104                  self.configure()
105              else:
106                  break


Б.6 Код стору автентифікації у браузерній частині

1    import { axiosIntance } from "../utils/axios";
2    import { User } from "../types/models";
3    import { JwtPayload, SignInResponse } from "../types/response";
4    import { jwtDecode } from "jwt-decode";
5    import { createWithEqualityFn } from "zustand/traditional";
6    import { SignUpDto } from "../types/dto";
7    
8    type AuthStore = {
9      user: User | null;
10     loading: boolean;
11     accessToken: string;
12     authReady: boolean;
13     register: (dto: SignUpDto) => Promise<any>;
14     login: (email: string, password: string) => Promise<any>;
15     logout: () => void;
16   };
17   
18   export const useAuth = createWithEqualityFn<AuthStore>((set) => ({
19     user: null,
20     loading: false,
21     accessToken: "",
22     authReady: false,
23     register: async (dto: SignUpDto) => {
24       const { data } = await axiosIntance.post<SignInResponse>(
25         "/auth/sign-up",
26         dto
27       );
28       const jwtPayload = jwtDecode<JwtPayload>(data.accessToken);
29       set({
30         accessToken: data.accessToken,
31         user: {
32           id: jwtPayload.sub,
33           ...jwtPayload.data,
34         },
35       });
36     },
37     login: async (email: string, password: string) => {
38       const { data } = await axiosIntance.post<SignInResponse>("/auth/sign-in", {
39         email,
40         password,
41       });
42       const jwtPayload = jwtDecode<JwtPayload>(data.accessToken);
43       set({
44         accessToken: data.accessToken,
45         user: {
46           id: jwtPayload.sub,
47           ...jwtPayload.data,
48         },
49       });
50     },
51     logout: () => {
52       set({
53         accessToken: "",
54         user: null,
55       });
56     },
57   }));


Б.7 Код сторінки для редагування запиту на сервісні роботи

1    import {
2      Button,
3      ComboboxData,
4      ComboboxItem,
5      Container,
6      Grid,
7      NumberInput,
8      Select,
9      Stack,
10     TextInput,
11     Textarea,
12   } from "@mantine/core";
13   import { useMaintenanceRequests } from "../../stores/use-maintenance-requests";
14   import { Controller, useForm } from "react-hook-form";
15   import { Navigate, useNavigate } from "react-router-dom";
16   import { useTranslation } from "react-i18next";
17   import { DateInput } from "@mantine/dates";
18   import { MaintenanceStatus, UserRole } from "../../types/enums";
19   import { useAuth } from "../../stores/use-auth";
20   import {
21     CUSTOMER_STATUS_OPTIONS,
22     EMPLOYEE_STATUS_OPTIONS,
23   } from "../../utils/constants";
24   import { TFunction } from "i18next";
25   import { useEffect } from "react";
26   
27   type FormState = {
28     status: MaintenanceStatus;
29     description: string;
30     rejectionReason?: string;
31     completeBy: Date;
32     price?: number;
33   };
34   
35   const getTranslatedStatusOptions = (t: TFunction, options: ComboboxData) => {
36     return options.map((option) => {
37       const comboboxItem = option as ComboboxItem;
38       comboboxItem.label = t(comboboxItem.label);
39       return comboboxItem;
40     });
41   };
42   
43   export const EditMaintenanceRequest = () => {
44     const { t } = useTranslation();
45     const navigate = useNavigate();
46     const role = useAuth((state) => state.user?.role);
47     const {
48       selectedMaintenanceRequest,
49       setSelectedMaintenanceRequest,
50       updateMaintenanceRequest,
51     } = useMaintenanceRequests(
52       ({
53         selectedMaintenanceRequest,
54         setSelectedMaintenanceRequest,
55         updateMaintenanceRequest,
56       }) => ({
57         selectedMaintenanceRequest,
58         setSelectedMaintenanceRequest,
59         updateMaintenanceRequest,
60       })
61     );
62   
63     const {
64       register,
65       control,
66       handleSubmit,
67       watch,
68       resetField,
69       formState: { isDirty },
70     } = useForm<FormState>({
71       mode: "onBlur",
72       defaultValues: selectedMaintenanceRequest ?? undefined,
73     });
74   
75     const onSubmit = async (data: FormState) => {
76       if (selectedMaintenanceRequest) {
77         await updateMaintenanceRequest(selectedMaintenanceRequest?.id, data);
78         setSelectedMaintenanceRequest(null);
79         navigate("../");
80       }
81     };
82   
83     const status = watch("status");
84   
85     const isEditable =
86       selectedMaintenanceRequest?.status &&
87       [
88         MaintenanceStatus.ClientUpdated,
89         MaintenanceStatus.ServiceUpdated,
90         MaintenanceStatus.Pending,
91       ].includes(selectedMaintenanceRequest?.status);
92   
93     const rejected = status === MaintenanceStatus.Rejected;
94     const canceled = status === MaintenanceStatus.Canceled;
95   
96     const statusOptions = getTranslatedStatusOptions(
97       t,
98       role === UserRole.Customer
99         ? CUSTOMER_STATUS_OPTIONS
100        : EMPLOYEE_STATUS_OPTIONS
101     );
102  
103    const defaultUpdatedStatus =
104      role === UserRole.Customer
105        ? MaintenanceStatus.ClientUpdated
106        : MaintenanceStatus.ServiceUpdated;
107  
108    useEffect(() => {
109      if (isDirty && status === selectedMaintenanceRequest?.status) {
110        resetField("status", {
111          defaultValue: defaultUpdatedStatus,
112        });
113      }
114    }, [isDirty, status]);
115  
116    if (!selectedMaintenanceRequest) {
117      return <Navigate to={"../"} />;
118    }
119  
120    return (
121      // @ts-ignore
122      <Container component={Stack} justify="center" size="md" h={"100%"}>
123        <Grid component={"form"} onSubmit={handleSubmit(onSubmit)}>
124          <Grid.Col span={6}>
125            <Stack gap={12}>
126              <TextInput
127                disabled
128                value={selectedMaintenanceRequest.car.model}
129                size="md"
130                label={t("car")}
131              />
132              <Controller
133                control={control}
134                name="price"
135                render={({ field: { value, onChange } }) => (
136                  <NumberInput
137                    min={1}
138                    size="md"
139                    label={t("price")}
140                    value={value}
141                    onChange={onChange}
142                  />
143                )}
144              />
145            </Stack>
146          </Grid.Col>
147          <Grid.Col span={6}>
148            <Stack gap={12}>
149              <TextInput
150                disabled
151                value={`${selectedMaintenanceRequest.station.name} - ${selectedMaintenanceRequest.station.address}`}
152                size="md"
153                label={t("station")}
154              />
155              <Controller
156                control={control}
157                name="completeBy"
158                render={({ field: { value, onChange } }) => (
159                  <DateInput
160                    minDate={new Date()}
161                    label={t("completeBy")}
162                    placeholder={t("completeBy")}
163                    size="md"
164                    value={value}
165                    onChange={onChange}
166                  />
167                )}
168              />
169            </Stack>
170          </Grid.Col>
171          <Grid.Col span={12} mt={8}>
172            <Textarea
173              label={t("description")}
174              placeholder={t("description")}
175              description={t("detailedDescription")}
176              resize="vertical"
177              size="md"
178              {...register("description")}
179            />
180          </Grid.Col>
181          <Grid.Col span={12} mt={8}>
182            <Controller
183              control={control}
184              name="status"
185              render={({ field: { value, onChange } }) => (
186                <Select
187                  data={statusOptions}
188                  value={value}
189                  onChange={onChange}
190                  size="md"
191                  label={t("status")}
192                />
193              )}
194            />
195          </Grid.Col>
196          {(rejected || canceled) && (
197            <Grid.Col span={12}>
198              <Textarea
199                label={t("rejectionReason")}
200                placeholder={t("rejectionReason")}
201                description={t(
202                  rejected ? "rejectionReasonDescription" : "canceledDescription"
203                )}
204                resize="vertical"
205                size="md"
206                {...register("rejectionReason")}
207              />
208            </Grid.Col>
209          )}
210          <Grid.Col span={12} mt={20}>
211            <Button
212              color="green"
213              type="submit"
214              fullWidth
215              disabled={!isDirty || !isEditable}
216            >
217              {t("save")}
218            </Button>
219          </Grid.Col>
220        </Grid>
221      </Container>
222    );
223  };


Б.8 Код компоненту для обмеження доступу до певних сторінок залежно від ролі

1    import { shallow } from "zustand/shallow";
2    import { useAuth } from "../stores/use-auth";
3    import { UserRole } from "../types/enums";
4    import { Navigate } from "react-router-dom";
5    import { PropsWithChildren } from "react";
6   
7    type Props = {
8      roles: UserRole[];
9    };
10   
11   export const RolesGuard = ({ roles, children }: PropsWithChildren<Props>) => {
12     const { user, authReady } = useAuth(
13       ({ user, authReady }) => ({
14         user,
15         authReady,
16       }),
17       shallow
18     );
19   
20     if (authReady) {
21       return null;
22     }
23   
24     const role = user?.role;
25   
26     return role && roles.includes(role) ? (
27       children
28     ) : (
29       <Navigate to={"/not-found"} />
30     );
31   };
